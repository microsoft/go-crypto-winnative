// Code generated by 'go generate'; DO NOT EDIT.

package bcrypt

import (
	"github.com/microsoft/go-crypto-winnative/internal/sysdll"
	"syscall"
	"unsafe"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modbcrypt   = syscall.NewLazyDLL(sysdll.Add("bcrypt.dll"))
	modkernel32 = syscall.NewLazyDLL(sysdll.Add("kernel32.dll"))
	modntdll    = syscall.NewLazyDLL(sysdll.Add("ntdll.dll"))

	procBCryptCloseAlgorithmProvider = modbcrypt.NewProc("BCryptCloseAlgorithmProvider")
	procBCryptCreateHash             = modbcrypt.NewProc("BCryptCreateHash")
	procBCryptDecapsulate            = modbcrypt.NewProc("BCryptDecapsulate")
	procBCryptDecrypt                = modbcrypt.NewProc("BCryptDecrypt")
	procBCryptDeriveKey              = modbcrypt.NewProc("BCryptDeriveKey")
	procBCryptDestroyHash            = modbcrypt.NewProc("BCryptDestroyHash")
	procBCryptDestroyKey             = modbcrypt.NewProc("BCryptDestroyKey")
	procBCryptDestroySecret          = modbcrypt.NewProc("BCryptDestroySecret")
	procBCryptDuplicateHash          = modbcrypt.NewProc("BCryptDuplicateHash")
	procBCryptEncapsulate            = modbcrypt.NewProc("BCryptEncapsulate")
	procBCryptEncrypt                = modbcrypt.NewProc("BCryptEncrypt")
	procBCryptExportKey              = modbcrypt.NewProc("BCryptExportKey")
	procBCryptFinalizeKeyPair        = modbcrypt.NewProc("BCryptFinalizeKeyPair")
	procBCryptFinishHash             = modbcrypt.NewProc("BCryptFinishHash")
	procBCryptGenRandom              = modbcrypt.NewProc("BCryptGenRandom")
	procBCryptGenerateKeyPair        = modbcrypt.NewProc("BCryptGenerateKeyPair")
	procBCryptGenerateSymmetricKey   = modbcrypt.NewProc("BCryptGenerateSymmetricKey")
	procBCryptGetFipsAlgorithmMode   = modbcrypt.NewProc("BCryptGetFipsAlgorithmMode")
	procBCryptGetProperty            = modbcrypt.NewProc("BCryptGetProperty")
	procBCryptHash                   = modbcrypt.NewProc("BCryptHash")
	procBCryptHashData               = modbcrypt.NewProc("BCryptHashData")
	procBCryptImportKeyPair          = modbcrypt.NewProc("BCryptImportKeyPair")
	procBCryptKeyDerivation          = modbcrypt.NewProc("BCryptKeyDerivation")
	procBCryptOpenAlgorithmProvider  = modbcrypt.NewProc("BCryptOpenAlgorithmProvider")
	procBCryptSecretAgreement        = modbcrypt.NewProc("BCryptSecretAgreement")
	procBCryptSetProperty            = modbcrypt.NewProc("BCryptSetProperty")
	procBCryptSignHash               = modbcrypt.NewProc("BCryptSignHash")
	procBCryptVerifySignature        = modbcrypt.NewProc("BCryptVerifySignature")
	procFormatMessageW               = modkernel32.NewProc("FormatMessageW")
	procRtlNtStatusToDosErrorNoTeb   = modntdll.NewProc("RtlNtStatusToDosErrorNoTeb")
)

func CloseAlgorithmProvider(hAlgorithm ALG_HANDLE, dwFlags uint32) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptCloseAlgorithmProvider.Addr(), uintptr(hAlgorithm), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func CreateHash(hAlgorithm ALG_HANDLE, phHash *HASH_HANDLE, pbHashObject []byte, pbSecret []byte, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbHashObject) > 0 {
		_p0 = &pbHashObject[0]
	}
	var _p1 *byte
	if len(pbSecret) > 0 {
		_p1 = &pbSecret[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptCreateHash.Addr(), uintptr(hAlgorithm), uintptr(unsafe.Pointer(phHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSecret)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func Decapsulate(hKey KEY_HANDLE, pbCiphertext []byte, pbSecret []byte, pcbResult *uint32, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbCiphertext) > 0 {
		_p0 = &pbCiphertext[0]
	}
	var _p1 *byte
	if len(pbSecret) > 0 {
		_p1 = &pbSecret[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptDecapsulate.Addr(), uintptr(hKey), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbCiphertext)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSecret)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func _Decrypt(hKey KEY_HANDLE, pbInput *byte, cbInput uint32, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput *byte, cbOutput uint32, pcbResult *uint32, dwFlags PadMode) (ntstatus error) {
	var _p0 *byte
	if len(pbIV) > 0 {
		_p0 = &pbIV[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptDecrypt.Addr(), uintptr(hKey), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbIV)), uintptr(unsafe.Pointer(pbOutput)), uintptr(cbOutput), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func DeriveKey(hSharedSecret SECRET_HANDLE, pwszKDF *uint16, pParameterList *BufferDesc, pbDerivedKey []byte, pcbResult *uint32, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbDerivedKey) > 0 {
		_p0 = &pbDerivedKey[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptDeriveKey.Addr(), uintptr(hSharedSecret), uintptr(unsafe.Pointer(pwszKDF)), uintptr(unsafe.Pointer(pParameterList)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbDerivedKey)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func DestroyHash(hHash HASH_HANDLE) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptDestroyHash.Addr(), uintptr(hHash))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func DestroyKey(hKey KEY_HANDLE) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptDestroyKey.Addr(), uintptr(hKey))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func DestroySecret(hSecret SECRET_HANDLE) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptDestroySecret.Addr(), uintptr(hSecret))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func DuplicateHash(hHash HASH_HANDLE, phNewHash *HASH_HANDLE, pbHashObject []byte, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbHashObject) > 0 {
		_p0 = &pbHashObject[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptDuplicateHash.Addr(), uintptr(hHash), uintptr(unsafe.Pointer(phNewHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashObject)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func Encapsulate(hKey KEY_HANDLE, pbSecret []byte, pcbResult *uint32, pbCiphertext []byte, pcbCiphertext *uint32, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbSecret) > 0 {
		_p0 = &pbSecret[0]
	}
	var _p1 *byte
	if len(pbCiphertext) > 0 {
		_p1 = &pbCiphertext[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptEncapsulate.Addr(), uintptr(hKey), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbSecret)), uintptr(unsafe.Pointer(pcbResult)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbCiphertext)), uintptr(unsafe.Pointer(pcbCiphertext)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func _Encrypt(hKey KEY_HANDLE, pbInput *byte, cbInput uint32, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (ntstatus error) {
	var _p0 *byte
	if len(pbIV) > 0 {
		_p0 = &pbIV[0]
	}
	var _p1 *byte
	if len(pbOutput) > 0 {
		_p1 = &pbOutput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptEncrypt.Addr(), uintptr(hKey), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbIV)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func ExportKey(hKey KEY_HANDLE, hExportKey KEY_HANDLE, pszBlobType *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptExportKey.Addr(), uintptr(hKey), uintptr(hExportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func FinalizeKeyPair(hKey KEY_HANDLE, dwFlags uint32) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptFinalizeKeyPair.Addr(), uintptr(hKey), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func FinishHash(hHash HASH_HANDLE, pbOutput []byte, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptFinishHash.Addr(), uintptr(hHash), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func GenRandom(hAlgorithm ALG_HANDLE, pbBuffer []byte, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbBuffer) > 0 {
		_p0 = &pbBuffer[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptGenRandom.Addr(), uintptr(hAlgorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbBuffer)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func GenerateKeyPair(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, dwLength uint32, dwFlags uint32) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptGenerateKeyPair.Addr(), uintptr(hAlgorithm), uintptr(unsafe.Pointer(phKey)), uintptr(dwLength), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func generateSymmetricKey(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, pbKeyObject []byte, pbSecret *byte, cbSecret uint32, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbKeyObject) > 0 {
		_p0 = &pbKeyObject[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptGenerateSymmetricKey.Addr(), uintptr(hAlgorithm), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbKeyObject)), uintptr(unsafe.Pointer(pbSecret)), uintptr(cbSecret), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func GetFipsAlgorithmMode(enabled *bool) (ntstatus error) {
	var _p0 uint32
	if *enabled {
		_p0 = 1
	}
	r0, _, _ := syscall.SyscallN(procBCryptGetFipsAlgorithmMode.Addr(), uintptr(unsafe.Pointer(&_p0)))
	*enabled = _p0 != 0
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func GetProperty(hObject HANDLE, pszProperty *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbOutput) > 0 {
		_p0 = &pbOutput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptGetProperty.Addr(), uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func Hash(hAlgorithm ALG_HANDLE, pbSecret []byte, pbInput []byte, pbOutput []byte) (ntstatus error) {
	var _p0 *byte
	if len(pbSecret) > 0 {
		_p0 = &pbSecret[0]
	}
	var _p1 *byte
	if len(pbInput) > 0 {
		_p1 = &pbInput[0]
	}
	var _p2 *byte
	if len(pbOutput) > 0 {
		_p2 = &pbOutput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptHash.Addr(), uintptr(hAlgorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbSecret)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbInput)), uintptr(unsafe.Pointer(_p2)), uintptr(len(pbOutput)))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func HashDataRaw(hHash HASH_HANDLE, pbInput *byte, cbInput uint32, dwFlags uint32) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptHashData.Addr(), uintptr(hHash), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func HashData(hHash HASH_HANDLE, pbInput []byte, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptHashData.Addr(), uintptr(hHash), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func ImportKeyPair(hAlgorithm ALG_HANDLE, hImportKey KEY_HANDLE, pszBlobType *uint16, phKey *KEY_HANDLE, pbInput []byte, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptImportKeyPair.Addr(), uintptr(hAlgorithm), uintptr(hImportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func KeyDerivation(hKey KEY_HANDLE, pParameterList *BufferDesc, pbDerivedKey []byte, pcbResult *uint32, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbDerivedKey) > 0 {
		_p0 = &pbDerivedKey[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptKeyDerivation.Addr(), uintptr(hKey), uintptr(unsafe.Pointer(pParameterList)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbDerivedKey)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func OpenAlgorithmProvider(phAlgorithm *ALG_HANDLE, pszAlgId *uint16, pszImplementation *uint16, dwFlags AlgorithmProviderFlags) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptOpenAlgorithmProvider.Addr(), uintptr(unsafe.Pointer(phAlgorithm)), uintptr(unsafe.Pointer(pszAlgId)), uintptr(unsafe.Pointer(pszImplementation)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func SecretAgreement(hPrivKey KEY_HANDLE, hPubKey KEY_HANDLE, phAgreedSecret *SECRET_HANDLE, dwFlags uint32) (ntstatus error) {
	r0, _, _ := syscall.SyscallN(procBCryptSecretAgreement.Addr(), uintptr(hPrivKey), uintptr(hPubKey), uintptr(unsafe.Pointer(phAgreedSecret)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func SetProperty(hObject HANDLE, pszProperty *uint16, pbInput []byte, dwFlags uint32) (ntstatus error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptSetProperty.Addr(), uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func SignHash(hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbInput []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (ntstatus error) {
	var _p0 *byte
	if len(pbInput) > 0 {
		_p0 = &pbInput[0]
	}
	var _p1 *byte
	if len(pbOutput) > 0 {
		_p1 = &pbOutput[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptSignHash.Addr(), uintptr(hKey), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func VerifySignature(hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbHash []byte, pbSignature []byte, dwFlags PadMode) (ntstatus error) {
	var _p0 *byte
	if len(pbHash) > 0 {
		_p0 = &pbHash[0]
	}
	var _p1 *byte
	if len(pbSignature) > 0 {
		_p1 = &pbSignature[0]
	}
	r0, _, _ := syscall.SyscallN(procBCryptVerifySignature.Addr(), uintptr(hKey), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHash)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSignature)), uintptr(dwFlags))
	if r0 != 0 {
		ntstatus = NTStatus(r0)
	}
	return
}

func formatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error) {
	var _p0 *uint16
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r0, _, e1 := syscall.SyscallN(procFormatMessageW.Addr(), uintptr(flags), uintptr(msgsrc), uintptr(msgid), uintptr(langid), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(args)))
	n = uint32(r0)
	if n == 0 {
		err = errnoErr(e1)
	}
	return
}

func rtlNtStatusToDosErrorNoTeb(ntstatus NTStatus) (ret syscall.Errno) {
	r0, _, _ := syscall.SyscallN(procRtlNtStatusToDosErrorNoTeb.Addr(), uintptr(ntstatus))
	ret = syscall.Errno(r0)
	return
}
